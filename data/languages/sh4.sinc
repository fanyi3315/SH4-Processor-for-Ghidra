# sleigh include file for Skeleton language instructions


define token SH4Instructions(16)
 	Rn    =  ( 8, 11)  # RN on the first 4 bits
 	Rn2   =  ( 4,  7)
 	Rm    =  ( 8, 11)  
 	Rm2   =  ( 4,  7)   
 	imm2  =  ( 4,  7)  
 	disp4 =  ( 0,  3)  
 	disp8 =  ( 0,  7)  # 8b
 	imm8  =  ( 0,  7)  # 8b
	quad3 =  ( 0,  3)
	quad2 =  ( 4,  7)
    quad1 =  ( 8, 11)
    quad0 =  (12, 15)
    mode  =  ( 2,  3)
    msize =  ( 0,  1)
    mode1 =  ( 2,  3)
    msize2=  ( 0,  1)
;
attach variables [ Rn Rm Rm2 ] [R0  R1  R2  R3  R4  R5  R6  R7 
                                 R8  R9  R10 R11 R12 R13 R14 R15 ];

#
################################################################
# Macros
################################################################

macro setResultFlags(result) {
	$(Z_flag) = (result == 0);
	$(S_flag) = (result s< 0);
}

macro setEQFlag(op1, op2) {
	$(T_flag) = (op1 == op2 );
}

macro setAddCarryFlags(op1,op2) {
	#$(C_flag) = (carry(op1,zext($(C_flag))) || carry(op2,op1 + zext($(C_flag))));
	$(C_flag) = carry(op1,op2); 
}

macro setAddCarryFlagsS(op1,op2) {
	$(C_flag) = scarry(op1,op2); 
	#$(C_flag) = (scarry(op1,sext($(C_flag))) || scarry(op2,op1 + sext($(C_flag))));
}

macro setAddFlags(op1,op2) {
	$(C_flag) = carry(op1,op2);
}

macro setSubtractCarryFlags(op1,op2) {
	notC = ~$(C_flag);
	$(C_flag) = ((op1 < sext(notC)) || (op2 < (op1 - sext(notC))));
}

macro setSubtractFlags(op1,op2) {
	$(C_flag) = (op1 < op2);
}

macro push16(val16) {
	SP = SP - 2;
	*:2 SP = val16; 
}

macro pop16(ret16) {
	ret16 = *:2 SP;
	SP = SP + 2; 
}

macro push8(val8) {
	SP = SP - 1;
	ptr:2 = SP;
	*:1 ptr = val8; 
}

macro pop8(ret8) {
    ptr:2 = SP;
	ret8 = *:1 ptr;
	SP = SP + 1; 
}

################################################################

#ixMem8: (IX+simm8)  is IX & simm8								{ ptr:2 = IX + simm8; export *:1 ptr; }
#ixMem8: (IX-val)    is IX & simm8 & sign8=1	[ val = -simm8; ]	{ ptr:2 = IX + simm8; export *:1 ptr; }
#iyMem8: (IY+simm8)  is IY & simm8								{ ptr:2 = IY + simm8; export *:1 ptr; }
#iyMem8: (IY-val)    is IY & simm8 & sign8=1	[ val = -simm8; ]	{ ptr:2 = IY + simm8; export *:1 ptr; }
#Addr16: imm16		is imm16									{ export *:1 imm16; }
#Mem16: (imm16)		is imm16									{ export *:2 imm16; }
#RelAddr8: loc		is simm8  [ loc = inst_next + simm8; ]		{ export *:1 loc; }

#cc: "NZ"            is bits3_3=0x0                              { c:1 = ($(Z_flag) == 0); export c; }
#cc: "Z"             is bits3_3=0x1                              { c:1 = $(Z_flag); export c; }
##cc: "NC"            is bits3_3=0x2                              { c:1 = ($(C_flag) == 0); export c; }
#cc: "C"             is bits3_3=0x3                              { c:1 = $(C_flag); export c; }
##cc: "PO"            is bits3_3=0x4                              { c:1 = ($(PV_flag) == 0); export c; }
#cc: "PE"            is bits3_3=0x5                              { c:1 = $(PV_flag); export c; }
#cc: "P"             is bits3_3=0x6                              { c:1 = ($(S_flag) == 0); export c; }
#cc: "M"             is bits3_3=0x7                              { c:1 = $(S_flag); export c; }
#
#cc2: "NZ"            is bits3_3=0x4                              { c:1 = ($(Z_flag) == 0); export c; }
#cc2: "Z"             is bits3_3=0x5                              { c:1 = $(Z_flag); export c; }
#cc2: "NC"            is bits3_3=0x6                              { c:1 = ($(C_flag) == 0); export c; }
#cc2: "C"             is bits3_3=0x7                              { c:1 = $(C_flag); export c; }

################################################################

# Question for Ghidra dude 
# How can I export a variable that define the size, so I can later use it when im defining an operator
#SZ: "B" valuesize is valuesize & msize=0 { local valuesize:1 = 1; export valuesize; }
#SZ: "W" valuesize is valuesize & msize=1 { local valuesize:1 = 2; export valuesize;}
#SZ: "L" valuesize is valuesize & msize=2 { local valuesize:1 = 4; export valuesize;}
# :MOV.^SZ Rm2, @Rn 			 is quad0=2 & mode=0 & msize=0 & Rm2 & Rn & SZ  {  *[ram]:valuesize Rn = SZ;  }

SZ: "B" is  msize=0 { }
SZ: "W" is  msize=1 { }
SZ: "L" is  msize=2 { }

cc: "EQ" is quad3 = 0 {  }

:MOV      "#"^imm8, Rn			is quad0=0xE & imm8 & Rn { 
	Rn = sext(imm8:2); }

# TODO: PC RELATIVE MOVE 
	#:MOV.W	@(disp8, PC), RN	is quad0=9 & disp8 & Rn { }
	#:MOV.L  @(disp8, PC), RN   	is quad0=0xd { }
	#:MOVA	  @(disp4, PC), R10  is quad0=C & quad1=7 & disp4 & PC & R0 { }

:MOV	  Rm2, Rn			is quad0=6 & quad3=3 & Rm2 & Rn   { Rn = Rm2; }
# :MOV.^SZ Rm2, @Rn
:MOV.B  Rm2, @Rn 			is quad0=2 & mode=0 & msize=0 & Rm2 & Rn  { *[ram]:1 Rn = Rm2;  }
:MOV.W  Rm2, @Rn 			is quad0=2 & mode=0 & msize=1 & Rm2 & Rn  { *[ram]:2 Rn = Rm2;  }
:MOV.L  Rm2, @Rn 			is quad0=2 & mode=0 & msize=2 & Rm2 & Rn  { *[ram]:4 Rn = Rm2;  }
# :MOV.^SZ @Rm2, Rn
:MOV.B  @Rm2, Rn          	is quad0=6 & mode=0 & msize=0 & Rm2 & Rn  { Rn = sext( *[ram]:1 Rm2); }
:MOV.W  @Rm2, Rn          	is quad0=6 & mode=0 & msize=1 & Rm2 & Rn  { Rn = sext( *[ram]:2 Rm2); }
:MOV.L  @Rm2, Rn          	is quad0=6 & mode=0 & msize=2 & Rm2 & Rn  { Rn = *[ram]:4 Rm2; }
# MOV.^SZ Rm, @-Rn
:MOV.B  Rm2, @-Rn 			is quad0=2 & mode=1 & msize=0 & Rm2 & Rn {
   addr = Rn -1;
   *[ram]:1 addr = Rm2:1;
   Rn = addr;
 }

:MOV.W  Rm2, @-Rn          	is quad0=2 & mode=1 & msize=1 & Rm2 & Rn { 
   addr = Rn -2;
   *[ram]:2 addr = Rm2:2;
   Rn = addr;
}
:MOV.L  Rm2, @-Rn          	is quad0=2 & mode=1 & msize=2 & Rm2 & Rn {
   addr = Rn - 4;
   *[ram]:4 addr = Rm2:4;
   Rn = addr;
 }


# Is this the right way?
# There is no else? Can we optimize?
# MOV.^SZ  @Rm2+, Rn 
:MOV.B  @Rm2+, Rn          is quad0=6 & mode=1 & msize=0 & Rm2 & Rn {
	local op2 = sext( *[ram]:1 Rm2 ); 

	if( Rm2 != Rn) goto <plusone>;
	 	Rm2 = op2;
	 	goto <done>;
     <plusone>
         Rm2 = Rm2 + 1;
    <done>
 }
:MOV.W  @Rm2+, Rn          is quad0=6 & mode=1 & msize=1 & Rm2 & Rn { 
	local op2 = sext( *[ram]:2 Rm2 ); 

	if( Rm2 != Rn) goto <plusone>;
	 	Rm2 = op2;
	 	goto <done>;
     <plusone>
         Rm2 = Rm2 + 1;
    <done>

}
:MOV.L  @Rm2+, Rn          is quad0=6 & mode=1 & msize=2 & Rm2 & Rn { 
	local op2 =  *[ram]:4 Rm2; 

	if( Rm2 != Rn) goto <plusone>;
	 	Rm2 = op2;
	 	goto <done>;
     <plusone>
         Rm2 = Rm2 + 1;
    <done>

}

:MOV.B    R0, @(disp4, Rn2)  is quad0=8 & quad1=0 & disp4 & Rn2 & R0 {
	tmpaddr:4 = Rn2 +  zext(disp4:1);
	*[ram]:1 tmpaddr = R0:1; 
 }
:MOV.W    R0, @(disp4, Rn2)  is quad0=8 & quad1=1 & disp4 & Rn2 & R0 { 
	tmpaddr:4 = Rn2 + zext(disp4:1) << 1;
	*[ram]:2 tmpaddr = R0:2;
}
:MOV.L	  Rm2, @(disp4, Rn)  is quad0=1 & disp4 & Rm2 & Rn { 
	tmpaddr:4 = Rn + zext(disp4:1) << 2;
	*tmpaddr = Rm2;
}

# 375
:MOV.B    @(disp4, Rm2), R0  is quad0=8 & quad1=4 & Rm2 & disp4 & R0 {
     tmpaddr:4 = zext(disp4:1) + Rm2;
     R0 = sext( *[ram]:1 tmpaddr ); 
 } 

:MOV.W    @(disp4, Rm2), R0  is quad0=8 & quad1=5 & Rm2 & disp4 & R0 {
     tmpaddr:4 = zext(disp4:1) + Rm2;
     R0 = sext( *[ram]:2 tmpaddr ); 
 } 
:MOV.L    @(disp4, Rm2), Rn  is quad0=5 & disp4 & Rm2 & Rn { 
     tmpaddr:4 = zext(disp4:1) + Rm2;
     R0 = *tmpaddr; 
}
:MOV.B  Rm2, @(R0, Rn) 	 is quad0=0 & mode=1 & msize=0 & Rm2 & R0 & Rn {
	tmpaddr = R0 + Rn;
	 *[ram]:1 tmpaddr = Rm2:1;

 }
:MOV.W  Rm2, @(R0, Rn) 	 is quad0=0 & mode=1 & msize=1 & Rm2 & R0 & Rn {
	tmpaddr = R0 + Rn;
	 *[ram]:2 tmpaddr = Rm2:2;

 }

:MOV.L  Rm2, @(R0, Rn) 	 is quad0=0 & mode=1 & msize=2 & Rm2 & R0 & Rn  {
	tmpaddr = R0 + Rn;
	 *[ram]:4 tmpaddr = Rm2;

 }

:MOV.B  @(R0, @Rm2), Rn 	 is quad0=0 & mode=3 & msize=0 & Rm2 & R0 & Rn {
	tmpaddr = R0 + Rm2;
	Rn = sext( *[ram]:1 tmpaddr);
 }
:MOV.W  @(R0, @Rm2), Rn 	 is quad0=0 & mode=3 & msize=1 & Rm2 & R0 & Rn {
	tmpaddr = R0 + Rm2;
	Rn = sext( *[ram]:2 tmpaddr);
 }
:MOV.L  @(R0, @Rm2), Rn 	 is quad0=0 & mode=3 & msize=2 & Rm2 & R0 & Rn {
	tmpaddr = R0 + Rm2;
	Rn = sext( *[ram]:4 tmpaddr);
 }

:MOV.B R0, @(disp8, GBR)  is quad0=0xC & mode1=0 & msize2=0 & R0 & disp8 & GBR { 
	tmpaddr:4 = zext( disp8:2) + GBR;
	*[ram]:1 tmpaddr = R0:1; 	
}
:MOV.W R0, @(disp8, GBR)  is quad0=0xC & mode1=0 & msize2=1 & R0 & disp8 & GBR { 
	tmpaddr:4 = zext( disp8:2) + GBR;
	*[ram]:2 tmpaddr = R0:2; 	
}
:MOV.L R0, @(disp8, GBR)  is quad0=0xC & mode1=0 & msize2=2 & R0 & disp8 & GBR { 
	tmpaddr:4 = zext( disp8:2) + GBR;
	*[ram]:4 tmpaddr = R0; 	
}


:MOV.B @(disp8, GBR),R0   is quad0=0xC & mode1=1 & msize2=0 & R0 & disp8 & GBR { 
	tmpaddr:4 = zext( disp8:2) + GBR;
	R0 = sext(*[ram]:1 tmpaddr); 	
}
:MOV.W @(disp8, GBR),R0   is quad0=0xC & mode1=1 & msize2=1 & R0 & disp8 & GBR { 
	tmpaddr:4 = zext( disp8:2) + GBR;
	R0 = sext(*[ram]:2 tmpaddr); 	
}
:MOV.L @(disp8, GBR),R0   is quad0=0xC & mode1=1 & msize2=2 & R0 & disp8 & GBR { 
	tmpaddr:4 = zext( disp8:2) + GBR;
	R0 = *[ram]:4 tmpaddr; 	
}
:MOVT     Rn 				 is quad0=0 & quad2=2 & quad3=9 & Rn { Rn = zext($(T_flag)); }

:SWAP.B   Rm2, Rn            is quad0=6 & quad3=8 & Rm2 & Rn  { }
:SWAP.W   Rm2, Rn            is quad0=6 & quad3=9 & Rm2 & Rn  { }
:XTRCT    Rm2, Rn            is quad0=2 & quad3=0xD & Rm2 & Rn { }

#
:ADD 	  Rm2, Rn 			 is quad0=3 & quad3=0xC & Rm2 & Rn { 
	 Rn = Rm2 + Rn; } 
:ADD      "#"^imm8, Rn 		 is quad0=7 & imm8 & Rn { 
	Rn = Rn + sext(imm8:2); } 

:ADDC  	  Rm2, Rn 			 is quad0=3 & quad3=0xE & Rm2 & Rn {
	Rn = Rm2 + Rn;
	setAddCarryFlags(Rn, Rm2);
}
:ADDV  	  Rm2, Rn 			 is quad0=3 & quad3=0xF & Rm2 & Rn {
	Rn = Rm2 + Rn;
	setAddCarryFlagsS(Rn, Rm2);
}
:AND      Rm2, Rn 			 is quad0=2 & quad3=0x9 & Rm2 & Rn {
	Rn = Rm2 & Rn;
}

:AND      "#"^imm8, R0 			 is quad0=0xC & quad1=0x9 & R0 & imm8 {
	R0 = R0 & zext(imm8:2);
}

# XXX: This is a draft, requires a second review. 
:AND.B 	  "#"^imm8, @(R0, GBR)		is quad0=0xC & quad1=0xD & R0 & GBR & imm8 {
	tmp = R0 + GBR;
	tmpimm = *[ram]:2 tmp & imm8:2;
	*[ram]:2 tmp = tmpimm;
}



